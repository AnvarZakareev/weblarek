// Покупатель:
interface IBuyer {
  payment: TPayment;
  email: string;
  phone: string;
  address: string;
} 

// Способ оплаты:
type TPayment = "card" | "cash" | "";	

export class Buyer {
    private Buyer: IBuyer | null;
    constructor (Buyer: IBuyer) {
        this.Buyer = Buyer;
    }
// Методы класса:

// сохранение данных в модели. Один общий метод или отдельные методы для каждого поля.
// Важно учесть, что должна быть реализована возможность сохранить только одно значение, 
// например, только адрес или только телефон, не удалив при этом значения других полей, 
// которые уже могут храниться в классе;
    // saveBuyerData(): IBuyer {

    // }
    // получение всех данных покупателя
    getBuyerData(): IBuyer | null {
        if (this.Buyer) {
            return this.Buyer as IBuyer;
        }
        return null;
    }
    // очистка данных покупателя
    clearBuyerData(): void {
        this.Buyer = null;
    }
    // Поле является валидным, если оно не пустое. 
    // Подсказка: Как один из вариантов решения задачи валидации может быть метод,
    // который вернет объект. В объекте могут присутствовать поля, 
    // соответствующие полям класса, значениями у которых будет текст ошибки. 
    // Если же поле не содержит ошибок, то такое свойство в объекте может отсутствовать.
    //       {
        //       payment: 'Не выбран вид оплаты',
        //       email: 'Укажите емэйл',
        //       } 
        //       Такой объект будет сообщать о валидности полей с телефоном и адресом и наличии 
        // ошибок в полях с видом оплаты и емэйлом. Можно сделать и отдельные методы для каждого 
        // поля, выбор за вами.
        //   Метод валидации должен давать возможность определить не только валидность каждого 
        // отдельного поля, 
        //   но и предоставлять информацию об ошибке, связанной с проверкой конкретного значения
        // валидация данных
        // validBuyerData(): boolean {
    
        // }
    }